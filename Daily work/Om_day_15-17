# Numpy provides efficient storage, better ways of handling data for processing. It is fast & easy to learn and Numpy uses 
# relatively less memory to store data.
#Declaration of Numpy array : arr = np.array([1, 2, 3, 4, 5])
#                             print(arr)
#ex : import numpy as np
#     arr = np.array([1, 2, 3, 4, 5]) #This is 1-dimensional array
#     print(arr)  #Output : [1, 2, 3, 4, 5]
#     arr.shape   #displays number of rows & columns, here – (1, 5)
#    arr.dtype   # dtype(‘int32’) or dtype(‘int64’)
#   arr.size    #Displays the number of elements in the array – 5

#ex: 
#arr1 = np.array([[1, 2, 3], [4, 5, 6]])  #2-dimensional array
#print(arr1)    #[[1 2 3]     
#                 [4 5 6]]
#print(arr1[0,2]) – ‘0’ indicates first row and ‘2’ indicates third column, output – 3
#arr1.sum(axis = 0) – 0 indicates first column, addition of first column – 1 + 4 = 5
#arr1.sum(axis = 1) – 1 indicates first row, addition of first row – 1 + 2 + 3 = 6
#arr1.argmax() – gives the index number of largest number in the array – 5
#arr1.max() – gives the largest number in the array – 6

#ex : 
#arr2 = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
#arr2.T – Transpose of matrix – [[1 4 7]
#                                [2 5 8]
#                                [3 6 9]]
#arr2.ndim – number of dimensions/axes – 2
#arr2.nbytes – Total bytes consumed 
#if 32 bit – one element – 4 bytes, Total bytes consumed = 4 * 9 = 36
#if 64 bit – one element – 8 bytes, Total bytes consumed = 8 * 9 = 72
#np.count_nonzero(arr2) – number of elements which are non-zero – 6
#arr2.sum() – addition of all elements of array – 45
#arr2.ravel – array([1, 2, 3, 4, 5, 6, 7, 8, 9])
#rng = np.arange(10) – [0 1 2 3 4 5 6 7 8 9]
#print(np.zeros((2, 3))) –  prints an array of 2 rows, 3columns with all zeros in the array.   
#            [[0. 0. 0.]
#             [0. 0. 0.]]
#np.sqrt(array name) – square root of each element of array.
#arr1 + arr2, arr1 * arr2 – only when the order of the arrays is same.
#np.where(array name > any number) – displays the index number of the element of the array which satisfies the specified condition.
#Ex : arr = np.array([[1, 8, 2], [4, 5, 8], [9, 0, 1]])
#     np.where(arr > 5) 
#Elements at (0,1), (1,2), (2,0) are greater than 5.
#Output : (array([0, 1, 2]), array([1, 2, 0]))
#Mean – np.mean(array name), Median – np.median(array name), 
#Standard deviation – np.std(array name), Correlation – np.corrcoef(arr1, arr2)

# Indexing : accessing different elements of the array.
# Ex : 
# arr = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
# print(arr[0,1])   #2               print(arr[1,3]) – Index error -3rd index doesn’t exists in arr
# print(arr[2,2])  #9                print(arr[2,0]) - #7
# print(arr[arr > 6])    #[7 8 9]       
# print(arr[(arr > 4) & (arr < 8)])  #[5 6 7]
# print(arr[[0, 2], [1, 0], [2, 1]])  #[3 4 8]

# Slicing : It is a way to access a subset of the elements  of a numpy array. It uses colon : 
# Ex :
# arr = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
# print(arr)
# print(arr[0:2, 1:3]) – 0:2 - rows from index 0 to index 2 (rows 0 & 1 not 2), 
# 1:3 - 1st,2nd  indexed columns.  Output : [[1 2 3]
#                                            [4 5 6]
#                                            [7 8 9]]
#                                           [[2 3]
#                                            [5 6]]

# print(arr[::2, ::2])  - ::2 – 0, 2 indexed rows, ::2 – 0, 2 indexed columns
# Output : [[1 3]
#           [7 9]]
# print(arr[-2, -1]) – last row = -1, 2nd  last row = -2, 1st row = -3        output : 6
# 1st  column = -3, 2nd column = -2, 3rd column = -1.                  

# Reshaping : Changing the shape of the array.
# Example can be converting a 1-D array into a 3*3 array, by using arr.reshape(3, 2) where there are 3 rows & 2 columns. flatten() function converts multi-dimensional array into a single 1-D array.

# Broadcasting refers to how numpy traets with different dimensions during arithmetic operations which lead to certain constraints, the smaller array is broadcast across larger array so that they have compatible shapes.
# Ex: 
# a = np.array([[0.0,0.0,0.0], [10.0,10.0,10.0], [20.0,20.0,20.0]])
# b = np.array([1.0,2.0,3.0])           output : [[1.0 2.0 3.0]
# print(a+b)                                      [11.0 12.0 13.0]
#                                                 [21.0 22.0 23.0]]

# a = np.array([11, 15, 18])                                   
# b = np.array([3])
# print(a-b)  #Output : [8 12 15]

# Vectorization is the process of performing various operations of arrays without the use of loops. Examples include declaring two arrays and multiplying them in the print statement like print(array 1 * array 2), Using sqrt function for calculating the square root of array elements.

# Advanced Multidimensional Array Operations : 
# 1.	Playing with axes : Transpose of a Array : can be done using array_name.T, np.transpose(array_name)
# 2.	swapping axes, 
# ex : a = np.array([[[1,4], [2,8]], [[3,6], [5, 10]]])     Output : [[1 4]       [[1 3]
#        print(a)                                                     [2 8]]       [2 5]]
#        print(np.swapaxes(a, 0, 2))                                  [[3 6]      [[4 6]
#                                                                      [5 10]]     [8 10]]
#              Axes 0 & 2 are swapped.
# 3.	  Performing aggregate calculations like : 
# Addition : ex: print(np.sum(array_name, axis=0))
# Mean & Standard deviation : np.mean(array_name) & np.std(array_name)
# min, max : ex : np.min(array_name, axis=1)
# Cumulative :  a = np.array([[3, 2, 9], [7, 4, 3]])
#                        print(np.cumsum(a))  #output : [3 5 14 21 25 28]
#                        print(np.cumprod(a))  #output : [3 6 54 378 1512 4536]                                                                     

