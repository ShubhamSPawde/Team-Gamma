# List Comprehension is creating lists with less code. It enhances code performance by being faster & more efficient than for loops.
# Ex : simple code : nos = [ ]                                          list comprehension : 
#                             for x in range(11):                             nos = [x * 2 for x in range(11)]
#                                   nos.append(x*2)                           print(nos)
#                                   print(nos)                Output : [0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20]

# ex : letters = [‘A’, ‘B’, ‘C’]
#        numbers = [1, 2, 3, 4]
#        combined = [[n,1] for n in numbers for 1 in letters]
#        print(combined)              Output : [[1, ‘A’], [1, ‘B’], [1, ‘C’], [2, ‘A’]……….[4,’C’]]

# List Comprehension is the best way to enhance code readability so it's beneficial to use it when there is a lot of data to be checked with the same function or logic.

# Generator Expression provides a convenient way to implement the iterator protocol(iterate over a sequence of data)

# Ex : gen_exp = (x * 2 for x in range(11) if x % 2 == 0)
#        for x in gen_exp:                       Output : 0 4 8 12 16 20
#            print(x)                                             
# The only difference between List Comprehension & Generator Expression is the use of brackets and the type of data returned by both of them is different.
# Ex : list_comp = [x ** 2 for x in range(10) if x % 2 == 0]
#        gen_exp = (x ** 2 for x in range(10) if x % 2 == 0)
#        print(list_comp)            # Output : [0, 4, 16, 36, 64]
#        print(gen_exp)              # Output : <generator object <genexpr> at 0x7f52a53a90>
# For generator exp we need to loop over it.
# Generator Exp occupies less size than List Comprehension.
# In List comprehension all the elements are stored in memory and we can get quick access to them. 
# In generator exp it saves the memory but requires entire list to be generated each time it is called to get the next element.

# Decorators
# Decorators are a very good feature which allows us to modify or extend the behaviour of functions  or classes. 
# It provides a clean way to implement cross – cutting concerns(aspects of program that affects multiple parts of an application) such as 
# logging, authentication & caching without affecting the core functionality.

# Decorators are applied to function or classes using @ with decorator’s name.
# Ex : @staticmethod
#        def my_static_method():

# Uses :     1. Performance measurement
#            2. Authentication and Authorization
#            3. Logging and error handling

# Context Managers
# Context Managers help manage resources such as file handles, sockets, database connections ensuring that they are properly acquired and released. 
# They simplify the process of manging resources by automatically handling setup & teardown operations, making the code more readable and less error-prone.

# Context managers are used in conjunction with the ‘with’ statement.
# Ex: with open(‘file.txt’, ‘r’) as file:
#             content = file.read()
#             print(content)

# The ‘contextlib’ module provides a simpler way to create context managers using the @contextmanager decorator and yield statement.   

# Uses : 1. File Handling & I/O operations
#            2. Database connections & transactions
#            3. Locks and synchronization in multithreading 

