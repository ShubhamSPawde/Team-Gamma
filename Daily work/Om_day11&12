# Class is a user-defined data type that acts as a blueprint for creating objects. 
# It defines a set of attributes(variables) and methods(functions) that the created objects will have.

# Object is an instance of a class. When a class is defined no memory is allocated until an object of that class is created. 
# Each object can have unique attribute values, but the structure and behavior defined by class are shared across all objects of that class.

# Ex : 
# class Car:
#     def __init__(self, name, price, color):
#         self.name = name
#         self.price = price
#         self.color = color
        
#     def __repr__(self):
#         return f"Car: {self.name}, price: {self.price}, color: {self.color}"

# car1 = Car('Car 1', 50000, 'Black')
# car2 = Car('Car 2', 65000, 'White')
                                                                     
# print(car1)                                                           
# print(car2)

# Output : Car: Car 1, price: 50000, color: Black
#               Car: Car 2, price: 65000, color: White

# -	The class name has to be started with capital letter and there should not be separate words.
# -	__init__ method is called as constructer and it sets the initial state of the object.
# -	The ‘self’ in python represents an instances of a class. By using it we can access the attributes & methods of the class.
# -	name, price & color are attributes.
# -	To access the attributes the dot notation is used.
# -	__repr__ method defines a string representation of an object that is meant to be clear & useful for developers.

# Encapsulation is the process of preventing others(mainly clients) from accessing properties, which can only be accessed through specific methods.
# Private attributes are inaccessible attributes. For a private attribute we need to use two underscores ‘__’ before the attribute name.
# Ex : Let’s introduce a private attribute in our previous example : __discount

# class Car:
#     def __init__(self, name, price, color):
#         self.name = name
#         self.price = price
#         self.color = color
#         self.__discount = 0.20
        
#     def __repr__(self):
#         return f"Car: {self.name}, price: {self.price}, color: {self.color}"

# car1 = Car('Car 1', 50000, 'Black')
                                                                     
# print(car1.name)
# print(car1.price)
# print(car1.color)
# print(car1.__discount)

# On running the above program, everything gets printed except discount, we need to use getter & setter methods to access private attributes.
# We make price property private, using setter method assign discount attribute and using getter function we get the price attribute : 

# class Car:
#     def __init__(self, name, color, price):
#         self.name = name
#         self.color = color
#         self.__price = price
#         self.__discount = None

#     def set_discount(self, discount):
#         self.__discount = discount

#     def get_price(self):
#         if self.__discount:
#             return self.__price * (1 - self.__discount)
#         return self.__price
            
#     def __repr__(self):
#         return f"Car: {self.name}, color: {self.color}, price: {self.get_price()}"

# car1 = Car('Car 1', 'Black', 50000)
# car1.set_discount(0.20)
# car2 = Car('Car 2', 'White', 65000)
                                                                     
# print(car1)                                                           
# print(car2)

# Output :  Car: Car 1, color: Black, price: 40000.0
#           Car: Car 2, color: White, price: 65000

# Inheritance
# A class’s ability to inherit methods or characteristics from another class is known as Inheritance.
# The subclass or child class is the class that inherits and superclass or parent class is the class from which methods or characteristics are inherited.
# Ex : Let’s add two new classes to our class Car :

# class Car:
#     def __init__(self, name, color, price):
#         self.name = name
#         self.color = color
#         self.__price = price
#         self.__discount = None
        
#     def set_discount(self, discount):
#             self.__discount = discount
        
#     def get_price(self):
#             if self.__discount:
#                 return self.__price * (1 - self.__discount)
#             return self.__price
            
#     def __repr__(self):
#             return f"Car: {self.name}, color: {self.color}, price: {self.get_price()}"

# class Suv(Car):
#     def __init__(self, name, color, price):
#         super().__init__(name, color, price)

# class Hatchback(Car):
#     def __init__(self, name, color, price):
#         super().__init__(name, color, price)

# car1 = Car('Car 1', 'Black', 50000)
# car1.set_discount(0.20)
# car2 = Car('Car 2', 'White', 65000)

# suv1 = Suv('Suv 1', 'Red', 70000)
# hatchback1 = Hatchback('Hatchback 1', 'Grey', 60800)
# hatchback1.set_discount(0.15)
                                                                     
# print(car1)         Output : Car: Car 1, color: Black, price: 40000.0                                                  
# print(car2)                  Car: Car 2, color: White, price: 65000
# print(suv1)                  Car: Suv 1, color: Red, price: 70000
# print(hatchback1)            Car: Hatchback 1, color: Grey, price: 51680.0

# Polymorphism in Greek means “something that takes on multiple forms”.
# It refers to a subclass’s ability to adapt new method that is already present in its superclass to meet its needs. Subclass can also modify it or use as it is.
# In above example we can use __repr__ method for class Suv and even if we do not use for both the subclasses then also it can be inherited from their parent class.
# Ex :  
# class Suv(Car):
#     def __init__(self, name, color, price):
#         super().__init__(name, color, price)
   
#     def __repr__(self):
#          return f”Car: {self.name}, color: {self.color}, price: {self.get_price()}"

# We can also modify the attributes for this subclass.
# An Abstract class is a class that cannot be instantiated directly and is meant to be subclassed. 
# It can contain abstract methods(methods without implementation) which are implemented by subclasses & concrete methods which provide default behaviour. 
# They are implemented using the ‘abc’ module.

# Python does not have a built-in concept of Interfaces like Java. Here Interface refers to a class that defines a set of methods that 
# any implementing class must provide, without providing any implementation itself.

# Ex : Let’s add an abstract base class Vehicle and interface for cars with discount named as Discountable.

# from abc import ABC, abstractmethod

# class Vehicle(ABC):
#     def __init__(self, name, color, price):
#         self.name = name
#         self.color = color
#         self._price = price
#         self._discount = None

#     def set_discount(self, discount):
#         self._discount = discount

#     @abstractmethod  
#     def get_price(self):
#         pass

#     def __repr__(self):
#         return f"Vehicle: {self.name}, color: {self.color}, price: {self.get_price()}"


# class Discountable(ABC):
#     @abstractmethod
#     def set_discount(self, discount):
#         pass

#     @abstractmethod
#     def get_price(self):
#         pass

# class Car(Vehicle, Discountable):
#     def get_price(self):
#         if self._discount:
#             return self._price * (1 - self._discount)
#         return self._price

# class Suv(Car):
#     def __init__(self, name, color, price):
#         super().__init__(name, color, price)

# class Hatchback(Car):
#     def __init__(self, name, color, price):
#         super().__init__(name, color, price)

# car1 = Car('Car 1', 'Black', 50000)
# car1.set_discount(0.20)
# car2 = Car('Car 2', 'White', 65000)

# suv1 = Suv('Suv 1', 'Red', 70000)
# hatchback1 = Hatchback('Hatchback 1', 'Grey', 60800)
# hatchback1.set_discount(0.15)

# print(car1)        Output : Vehicle: Car 1, color: Black, price: 40000.0
# print(car2)                 Vehicle: Car 2, color: White, price: 65000
# print(suv1)                 Vehicle: Suv 1, color: Red, price: 70000
# print(hatchback1)           Vehicle: Hatchback 1, color: Grey, price: 51680.0
